## Steps

**1. Create the agent software.**

Paths to creating agent software are still evolving rapidly, and there will undoubtedly be many more means to have an agent in the near future, including purchasing a hosted or on-premises solution from a provider such as Evernym.  At the time of this writing, agents will likely be custom, based on either the python demonstration software from the Sovrin *Getting Started Guide*, or on the indy-sdk.  This document assumes that the agent will be based on the python demonstration software.

As with all entities on the Sovrin ledger, the trust anchor and its agent will be identified and able to authenticate itself using a public-private key pair.  The running code will need its private key to be able to interact with other entities and their agents, so that will need to be available to it.  The means used for this in the demo code is to hard-code a seed that is used to generate the public and private keys for the use of the agent.  For example, in the demo “Faber” agent, the seed is defined as `“Faber000000000000000000000000000”`, and a call later in the code generates public and private keys from this, placing them in the agent’s wallet.

```
FABER_SEED = b'Faber000000000000000000000000000'
FABER_SIGNER = DidSigner(seed=FABER_SEED)
FABER_ID = FABER_SIGNER.identifier
FABER_VERKEY = FABER_SIGNER.verkey
…
wallet = Wallet(name)
wallet.addIdentifier(signer=FABER_SIGNER)
```
Further discussion of the particulars of coding the agent are outside of the scope of this document.  The demo code itself is a good resource for seeing how to do agent coding of this type.  It is located at /usr/local/lib/python3.5/dist-packages/sovrin_client/test/agent/ on VMs on which Sovrin has been installed.

The corresponding public key that is generated from the seed in the agent code will be used by clients to connect to the agent.  The public key will be expressed as a DID and verkey pair that must be placed onto the ledger and must be embedded into requests to connect that are issued to clients.

**2. Put the Trust Anchor credentials onto the ledger.**

The public key that is produced by the seed can be expressed as a DID / verkey pair that is placed on the Sovrin ledger.  You can find the value of these parameters using any Sovrin CLI client.  After getting to the Sovrin prompt, enter “new key with seed XXXX”, where XXXX is the 32-bit seed.  For example, the DID and verkey for Faber are determined as follows:

```
sovrin@test&gt; new key with seed Faber000000000000000000000000000
Key created in wallet Default-4b260e
DID for key is ULtgFQJe6bjiFbs7ke3NJD
Verification key is ~5kh3FB4H3NKq7tUDqeqHc1
Current DID set to ULtgFQJe6bjiFbs7ke3NJD
```

The DID and verkey returned are those that are placed onto the ledger for the Faber trust anchor. Note that the above values are identical to those used for the Faber trust anchor in the *Getting Started Guide*.  Trust  anchor credentials must be added to the ledger by a steward or trustee, which are roles that have privileges permitting them to do this.

The trust anchor credentials are placed onto the ledger using a CLI client that is connected to the Sovrin network, and is using the DID of a Steward or Trustee for authentication.  As an example, these are typical commands for placing the Faber agent onto the default Sovrin Testnet using the default Steward1 credentials that are configured for demo validator networks:

```
sovrin> connect test
sovrin@test> new key with seed 000000000000000000000000Steward1
sovrin@test> send NYM dest=ULtgFQJe6bjiFbs7ke3NJD role=TRUST_ANCHOR verkey=~5kh3FB4H3NKq7tUDqeqHc1
```

The `dest` and `verkey` values are those that are generated by the seed of the trust anchor, as shown above.

**Notes on the above commands:**  *The seed used for the steward is a default one that is baked into many Sovrin test networks.  If this was not such a network, a steward would have generated a random seed and used this to make his steward DID and verkey as outlined above.  This DID and verkey would have been put into the genesis transaction file for the network, or will have been added to the ledger by a trustee at a later time.*

**3. Pace the agent attributes onto the Sovrin ledger.**

Each trust anchor or identity owner can place attributes onto the ledger for various purposes. The attributes that we need concern ourselves with here are those needed to locate and connect to an agent. Each trust anchor or identity owner can have one agent identified on the ledger in his attributes. If a trust anchor desires to have more than one agent, he can create subsidiary identity owners on the ledger, each one with attributes set for one agent.

The attributes that should be placed on the ledger for an agent are:

* IP address: the static, publicly-accessible address where the agent runs.

* TCP port

The port on which the agent process listens for connection attempts.

* Pubkey

The zmq public key of the agent process.  (This is a key associated with zmq communications, not a Sovrin key.)

### Getting the Pubkey

The pubkey for the agent is generated by the zmq code, the first time that the agent runs.  To get it, go to the node that you will use for the agent, and start the agent.  For the Faber example, this is done by running the agent python script:

```
vagrant@agent01:~$ python3 /usr/local/lib/python3.5/dist-packages/sovrin_client/test/agent/faber.py  --port 5555
```

Since the agent has not yet been configured on the ledger, it will be unable to function properly, but it will write out the pubkey to a file. Type CTL-C to get back to the bash prompt and continue.  You must locate the pubkey and convert it to base58 form before putting it on the ledger.

The pubkey can be found after the agent has run, by running a simple python script on the agent node, or by duplicating its steps from the command line.  The script is in the appendix named “findPubkey.py”.  To use it, copy it to a file on your agent node, and type:

```
vagrant@agent01:~$ python3 findPubkey.py <agent_name>
```

Continuing with the Faber example, here is the python script invocation and its result:

```
vagrant@agent01:~$ python3 findPubkey.py FaberCollege
The pubkey from the file is: mC]o38gjVl]5JjuRQ7fO!mLpd12D1SJE:w<Ph%#V
The base58 encoded pubkey: 5hmMA64DDQz5NzGJNVtRzNwpkZxktNQds21q3Wxxa62z
```

With this information, the trust anchor is now able to add his agent attributes to the ledger, which he must do for himself.  After entering the command line on a CLI client, he should connect to the desired ledger, enter his trust anchor credentials, and then send a ledger transaction that will define his agent attributes, as follows. Using the trust anchor DID, IP address, port, and agent pubkey from the Faber example:

```
sovrin> connect test
sovrin@test> new key with seed Faber000000000000000000000000000
sovrin@test> send ATTRIB dest=ULtgFQJe6bjiFbs7ke3NJD raw={"endpoint": {"ha": "10.20.30.101:5555", "pubkey": "5hmMA64DDQz5NzGJNVtRzNwpkZxktNQds21q3Wxxa62z"}
```

**4. Start the agent process.**

Now that the trust anchor and attribute information needed to identify and define the trust anchor and its agent is on the Sovrin ledger, the process can be started. Following the Faber example, this is done by merely running the python script, as we did earlier to obtain the agent’s pubkey. This time, with all the needed transactions posted on the ledger, the agent acts as a server, awaiting client connections.

### Client Connection Requests

Requests to connect to an agent are assumed to be distributed to users through an unspecified external method. In the demos, this is done by reading canned files generated for this purpose. The most important things in the invitation files are:

>1) the DID of the trust anchor to connect to and  
>2) a nonce, matching a nonce in the agent code.

Using these two pieces of information, a client or its agent will be able to get connection information for the agent from the ledger, connect to the agent, and identify itself to the agent using the nonce.  The agent can then provide credentials, request proofs, or do similar transactions with the client. Sample connection requests can be found in /usr/local/lib/python3.5/dist-packages/sample/.

```
{
    "connection-request": {
    "name": "Faber College",
    "identifier": "ULtgFQJe6bjiFbs7ke3NJD",
    "nonce": "b1134a647eb818069c089e7694f63e6d"
    },
"sig": "4QKqkwv9gXmc3Sw7YFkGm2vdF6ViZz9FKZcNJGh6pjnjgBXRqZ17Sk8bUDSb6hsXHoPxrzq2F51eDn1DKAaCzhqP"
}
```

In the demo script, the above example connection request is issued by Faber College.  The `identifier` should be familiar by now as Faber’s trust anchor DID.  Examining the code, the nonce is for an connection request issued to the “Alice” user.  Nonces are just randomly generated numbers expressed as strings.  In the current implementation of the agent code, the signature, `sig,` is not checked by the agent code and does not matter.

**5. Using the agent.**

With the trust anchor (or identity owner) credentials and attributes on the Sovrin ledger, and with the corresponding agent process running on its node, a client is able to connect to and interact with the agent.  The following client-centric sequence is typical:

> 1. Get a request to connect to an agent (out-of-band of Sovrin).
2. Use the DID from the request to get connection parameters from the ledger:
  * IP address
  * Port
  * Pubkey
3. Use the above to establish an authenticated connection directly to the trust anchor’s agent.
4. Agent uses nonce to identify who is connecting.
  * Agent provides credentials, requests proof, etc.

There are many things not mentioned here that facilitate this sequence, such as pair-wise identifiers being written to the ledger, schemas being fetched for credentials and proofs, and more.  This level of detail are not needed here.
